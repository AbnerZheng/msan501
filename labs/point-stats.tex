\chapter{Computing Point Statistics}

\setcounter{problem}{1}
\section{Discussion}

\begin{fullwidth}

The goal of this task is to get familiar with Python function definitions and looping structures, as well as to refresh your memory about a few point statistics. 

\subsection{Stats}

First, we are going to write functions to compute sample mean and variance from a data set (list of values).  In mathematics notation, the sample estimates are:

\[\tag{Sample mean}
\bar x = \frac{1}{N} \sum_{i=1}^{N} x_i 
\]

\[\tag{Unbiased sample variance}
s^2 = \frac{1}{N-1} \sum_{i=1}^{N} (x_i - m)^2
\]

\[\tag{Unbiased sample covariance}
cov(x,y) = \frac{1}{N-1} \sum_{i=1}^{N} (x_i - \bar x)(y_i - \bar y)
\]

In Python, you must define functions {\tt mean(x)}, {\tt var(x)}, {\tt cov(x,y)} where {\tt x} and {\tt y} are objects that behave like a list or iteration. The functions return a floating-point value based on the above mathematics notation. If the length of the incoming vectors to {\tt cov} are not the same, return 0. To test things out, use the {\tt test\_stats.py} file provided for you as part of this task.

\subsection{Libraries}

While we're at it let's learn about importing libraries.  You'll notice that {\tt test\_stats.py} references your code like this:

\begin{pyverbatim}
from stats import *
\end{pyverbatim}

\noindent That lets us directly access the functions defined in your {\tt stats.py} file.
 
We can also test the correctness of the functions by using the {\tt numpy} lib. Be careful not to confuse function names; e.g., {\tt numpy} has functions with the same names (although cov() returns a covariance matrix).

\begin{pyverbatim}
import numpy as np  # np is an alias for the numpy library
x = ...
y = ...
print np.cov(x,y)[0][1] # np.cov returns cov matrix
\end{pyverbatim}

We now have the kernel of a small statistics library.

\section{Deliverables}

\begin{itemize}
\item {\tt stats.py}
\end{itemize}

\end{fullwidth}

